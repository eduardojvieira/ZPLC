/**
 * Test Debug Map Generation
 * 
 * Tests the advanced debugging infrastructure:
 * - Source annotations in assembly
 * - Assembler instruction mapping
 * - DebugMap building from compilation
 * - Source line to PC mapping
 * - Variable info extraction
 */

import { 
    compileToBinary, 
    findVariable, 
    findSourceLine, 
    findPC, 
    getBreakpointLocations,
    serializeDebugMap,
} from './src/compiler/index.ts';
import type { DebugMap } from './src/compiler/index.ts';

// Simple test program
const simpleProgram = `
PROGRAM TestProgram
VAR
    Counter : DINT := 0;
    Running : BOOL := TRUE;
END_VAR

Counter := Counter + 1;

IF Counter > 10 THEN
    Running := FALSE;
END_IF;

END_PROGRAM
`;

// Program with function block
const fbProgram = `
PROGRAM TimerTest
VAR
    MyTimer : TON;
    StartSignal : BOOL := FALSE;
    TimerDone : BOOL := FALSE;
END_VAR

MyTimer(IN := StartSignal, PT := T#1s);
TimerDone := MyTimer.Q;

END_PROGRAM
`;

console.log('='.repeat(60));
console.log('Debug Map Generation Tests');
console.log('='.repeat(60));
console.log();

// Test 1: Compile without debug map (default)
console.log('Test 1: Compile without debug map (default)');
{
    const result = compileToBinary(simpleProgram);
    console.log('  ✓ Compilation successful');
    console.log(`  - Assembly length: ${result.assembly.length} chars`);
    console.log(`  - Bytecode size: ${result.bytecode.length} bytes`);
    console.log(`  - Debug map present: ${result.debugMap ? 'YES' : 'NO'}`);
    
    if (result.debugMap) {
        console.log('  ✗ Debug map should NOT be present by default');
    } else {
        console.log('  ✓ Debug map correctly not generated by default');
    }
}
console.log();

// Test 2: Compile with debug map
console.log('Test 2: Compile with debug map enabled');
{
    const result = compileToBinary(simpleProgram, { generateDebugMap: true });
    console.log('  ✓ Compilation successful');
    console.log(`  - Assembly length: ${result.assembly.length} chars`);
    console.log(`  - Bytecode size: ${result.bytecode.length} bytes`);
    console.log(`  - Debug map present: ${result.debugMap ? 'YES' : 'NO'}`);
    
    if (!result.debugMap) {
        throw new Error('Debug map should be present when generateDebugMap is true');
    }
    
    const map = result.debugMap;
    console.log(`  - Program name: ${map.programName}`);
    console.log(`  - Compiler version: ${map.compilerVersion}`);
    console.log(`  - POU count: ${Object.keys(map.pou).length}`);
    
    // Check POU info
    const pouInfo = map.pou['TestProgram'];
    if (!pouInfo) {
        throw new Error('POU "TestProgram" not found in debug map');
    }
    
    console.log(`  - Variables: ${Object.keys(pouInfo.vars).length}`);
    console.log(`  - Source mappings: ${pouInfo.sourceMap.length}`);
    console.log(`  - Breakpoints: ${pouInfo.breakpoints.length}`);
    
    // Check variables
    console.log('  Variables:');
    for (const [name, info] of Object.entries(pouInfo.vars)) {
        console.log(`    - ${name}: ${info.type} @ 0x${info.addr.toString(16)}`);
    }
    
    console.log('  ✓ Debug map generated correctly');
}
console.log();

// Test 3: Source annotations in assembly
console.log('Test 3: Source annotations in assembly');
{
    const result = compileToBinary(simpleProgram, { generateDebugMap: true });
    const hasSourceAnnotations = result.assembly.includes('; @source');
    
    console.log(`  - Source annotations in assembly: ${hasSourceAnnotations ? 'YES' : 'NO'}`);
    
    if (!hasSourceAnnotations) {
        throw new Error('Assembly should contain @source annotations when debug map is enabled');
    }
    
    // Count annotations
    const annotationCount = (result.assembly.match(/; @source \d+/g) || []).length;
    console.log(`  - Annotation count: ${annotationCount}`);
    console.log('  ✓ Source annotations present');
}
console.log();

// Test 4: Source line to PC mapping
console.log('Test 4: Source line to PC mapping');
{
    const result = compileToBinary(simpleProgram, { generateDebugMap: true });
    const map = result.debugMap!;
    
    // Find source line for various PCs
    const pouInfo = map.pou['TestProgram'];
    console.log('  Source mappings:');
    for (const mapping of pouInfo.sourceMap.slice(0, 5)) {
        console.log(`    Line ${mapping.line} -> PC 0x${mapping.pc.toString(16)} (${mapping.length} bytes)`);
    }
    
    if (pouInfo.sourceMap.length > 0) {
        // Test findSourceLine
        const firstMapping = pouInfo.sourceMap[0];
        const found = findSourceLine(map, firstMapping.pc);
        if (found) {
            console.log(`  - findSourceLine(0x${firstMapping.pc.toString(16)}) = line ${found.line} in ${found.pou}`);
        }
        
        // Test findPC
        const pc = findPC(map, 'TestProgram', firstMapping.line);
        if (pc !== null) {
            console.log(`  - findPC('TestProgram', ${firstMapping.line}) = 0x${pc.toString(16)}`);
        }
    }
    
    console.log('  ✓ Source mapping works correctly');
}
console.log();

// Test 5: Breakpoint locations
console.log('Test 5: Breakpoint locations');
{
    const result = compileToBinary(simpleProgram, { generateDebugMap: true });
    const map = result.debugMap!;
    
    const breakpoints = getBreakpointLocations(map, 'TestProgram');
    console.log(`  - Valid breakpoint locations: ${breakpoints.length}`);
    
    for (const bp of breakpoints.slice(0, 5)) {
        console.log(`    Line ${bp.line} @ PC 0x${bp.pc.toString(16)}`);
    }
    
    console.log('  ✓ Breakpoint locations extracted');
}
console.log();

// Test 6: Variable lookup
console.log('Test 6: Variable lookup');
{
    const result = compileToBinary(simpleProgram, { generateDebugMap: true });
    const map = result.debugMap!;
    
    // Find Counter variable
    const counterVar = findVariable(map, 'Counter');
    if (counterVar) {
        console.log(`  - Counter: ${counterVar.varInfo.type} @ 0x${counterVar.absoluteAddr.toString(16)}`);
    } else {
        throw new Error('Counter variable not found');
    }
    
    // Find Running variable  
    const runningVar = findVariable(map, 'Running');
    if (runningVar) {
        console.log(`  - Running: ${runningVar.varInfo.type} @ 0x${runningVar.absoluteAddr.toString(16)}`);
    } else {
        throw new Error('Running variable not found');
    }
    
    console.log('  ✓ Variable lookup works');
}
console.log();

// Test 7: Function Block with members
console.log('Test 7: Function Block instance debugging');
{
    const result = compileToBinary(fbProgram, { generateDebugMap: true });
    const map = result.debugMap!;
    
    console.log(`  - Program: ${map.programName}`);
    
    const pouInfo = map.pou['TimerTest'];
    if (!pouInfo) {
        throw new Error('POU "TimerTest" not found');
    }
    
    console.log(`  - Variables: ${Object.keys(pouInfo.vars).length}`);
    
    // Check for TON instance
    const timerVar = pouInfo.vars['MyTimer'];
    if (!timerVar) {
        throw new Error('MyTimer variable not found');
    }
    
    console.log(`  - MyTimer: ${timerVar.type} @ 0x${timerVar.addr.toString(16)}`);
    
    if (timerVar.children) {
        console.log(`  - MyTimer members: ${Object.keys(timerVar.children).length}`);
        for (const [name, member] of Object.entries(timerVar.children)) {
            console.log(`    - .${name}: offset ${member.offset}, ${member.type}`);
        }
    }
    
    // Test path-based lookup
    const timerQ = findVariable(map, 'MyTimer.Q');
    if (timerQ) {
        console.log(`  - MyTimer.Q address: 0x${timerQ.absoluteAddr.toString(16)}`);
    }
    
    console.log('  ✓ FB instance debugging works');
}
console.log();

// Test 8: Debug map serialization
console.log('Test 8: Debug map serialization');
{
    const result = compileToBinary(simpleProgram, { generateDebugMap: true });
    const map = result.debugMap!;
    
    const json = serializeDebugMap(map);
    console.log(`  - JSON size: ${json.length} bytes`);
    
    // Verify it's valid JSON
    const parsed = JSON.parse(json);
    console.log(`  - Parsed version: ${parsed.version}`);
    console.log(`  - Parsed program: ${parsed.programName}`);
    
    console.log('  ✓ Serialization works');
}
console.log();

console.log('='.repeat(60));
console.log('All Debug Map tests passed!');
console.log('='.repeat(60));
