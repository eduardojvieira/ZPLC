"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6395],{2805(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>d,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"languages/il","title":"Instruction List (IL)","description":"Instruction List (IL) is a low-level, assembler-like language defined by IEC 61131-3. It is closer to the hardware execution model and is often used for small, optimized code segments.","source":"@site/docs/languages/il.md","sourceDirName":"languages","slug":"/languages/il","permalink":"/ZPLC/es/docs/languages/il","draft":false,"unlisted":false,"editUrl":"https://github.com/eduardojvieira/ZPLC/tree/master/docs/docs/languages/il.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Structured Text (ST)","permalink":"/ZPLC/es/docs/languages/st"},"next":{"title":"Standard Library","permalink":"/ZPLC/es/docs/languages/stdlib"}}');var t=s(4848),i=s(8453);const d={sidebar_position:2},l="Instruction List (IL)",c={},o=[{value:"Basic Concept",id:"basic-concept",level:2},{value:"Supported Instructions",id:"supported-instructions",level:2},{value:"Load / Store",id:"load--store",level:3},{value:"Logic &amp; Arithmetic",id:"logic--arithmetic",level:3},{value:"Modifiers",id:"modifiers",level:3},{value:"Jumps and Calls",id:"jumps-and-calls",level:3},{value:"Example Program",id:"example-program",level:2},{value:"Using IL in ZPLC IDE",id:"using-il-in-zplc-ide",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"instruction-list-il",children:"Instruction List (IL)"})}),"\n",(0,t.jsx)(n.p,{children:"Instruction List (IL) is a low-level, assembler-like language defined by IEC 61131-3. It is closer to the hardware execution model and is often used for small, optimized code segments."}),"\n",(0,t.jsxs)(n.p,{children:["ZPLC includes a fully-featured ",(0,t.jsx)(n.strong,{children:"IL Compiler"})," that translates IL source code directly into ZPLC bytecode."]}),"\n",(0,t.jsx)(n.h2,{id:"basic-concept",children:"Basic Concept"}),"\n",(0,t.jsx)(n.p,{children:'IL is stack-based accumulator logic. Most instructions operate on a "Current Result" (CR) register (conceptually the top of the stack).'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-il",children:"LD  Var1    (* Load Var1 into Accumulator *)\nADD 10      (* Add 10 to Accumulator *)\nST  Result  (* Store Accumulator to Result *)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"supported-instructions",children:"Supported Instructions"}),"\n",(0,t.jsx)(n.h3,{id:"load--store",children:"Load / Store"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Instruction"}),(0,t.jsx)(n.th,{children:"Operand"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"LD"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Load value to Accumulator (pushes to stack)."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"LDN"})}),(0,t.jsx)(n.td,{children:"Var"}),(0,t.jsx)(n.td,{children:"Load negated value."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ST"})}),(0,t.jsx)(n.td,{children:"Var"}),(0,t.jsx)(n.td,{children:"Store Accumulator to variable."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"STN"})}),(0,t.jsx)(n.td,{children:"Var"}),(0,t.jsx)(n.td,{children:"Store negated Accumulator."})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"logic--arithmetic",children:"Logic & Arithmetic"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Instruction"}),(0,t.jsx)(n.th,{children:"Operand"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"AND"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Bitwise AND with Accumulator."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"OR"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Bitwise OR with Accumulator."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"XOR"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Bitwise XOR with Accumulator."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"NOT"})}),(0,t.jsx)(n.td,{children:"-"}),(0,t.jsx)(n.td,{children:"Bitwise Invert Accumulator."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ADD"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Add to Accumulator."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SUB"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Subtract from Accumulator."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"MUL"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Multiply with Accumulator."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"DIV"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Divide Accumulator by operand."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"MOD"})}),(0,t.jsx)(n.td,{children:"Var / Const"}),(0,t.jsx)(n.td,{children:"Modulo operation."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"GT"}),", ",(0,t.jsx)(n.code,{children:"LT"}),", ",(0,t.jsx)(n.code,{children:"EQ"})]}),(0,t.jsx)(n.td,{children:"Var"}),(0,t.jsx)(n.td,{children:"Comparison (Result is BOOL)."})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"modifiers",children:"Modifiers"}),"\n",(0,t.jsxs)(n.p,{children:["Most instructions support the ",(0,t.jsx)(n.code,{children:"("})," (deferred) modifier, which acts like opening a parenthesis."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-il",children:"LD  A\nAND ( B   (* Push A, start new evaluation for B OR C *)\nOR  C\n)         (* Pop A, AND with (B OR C) *)\nST  D\n"})}),"\n",(0,t.jsx)(n.h3,{id:"jumps-and-calls",children:"Jumps and Calls"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Instruction"}),(0,t.jsx)(n.th,{children:"Operand"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JMP"})}),(0,t.jsx)(n.td,{children:"Label"}),(0,t.jsx)(n.td,{children:"Unconditional Jump."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JMPC"})}),(0,t.jsx)(n.td,{children:"Label"}),(0,t.jsx)(n.td,{children:"Jump if Accumulator is TRUE."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JMPCN"})}),(0,t.jsx)(n.td,{children:"Label"}),(0,t.jsx)(n.td,{children:"Jump if Accumulator is FALSE."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CAL"})}),(0,t.jsx)(n.td,{children:"FunctionBlock"}),(0,t.jsx)(n.td,{children:"Call a Function Block."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"RET"})}),(0,t.jsx)(n.td,{children:"-"}),(0,t.jsx)(n.td,{children:"Return from program/function."})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"example-program",children:"Example Program"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Structured Text:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-st",children:"IF StartBtn AND NOT StopBtn THEN\n    Motor := TRUE;\nELSE\n    Motor := FALSE;\nEND_IF;\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Equivalent Instruction List:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-il",children:"    LD   StartBtn\n    ANDN StopBtn\n    ST   Motor\n"})}),"\n",(0,t.jsx)(n.h2,{id:"using-il-in-zplc-ide",children:"Using IL in ZPLC IDE"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create a new file with the ",(0,t.jsx)(n.code,{children:".il"})," extension."]}),"\n",(0,t.jsxs)(n.li,{children:["Write your program inside ",(0,t.jsx)(n.code,{children:"PROGRAM ... END_PROGRAM"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"The compiler will automatically detect the language and generate the corresponding bytecode."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-il",children:"PROGRAM Main\n    VAR\n        Counter : INT := 0;\n        Limit : INT := 100;\n    END_VAR\n\n    LD  Counter\n    ADD 1\n    ST  Counter\n\n    LD  Counter\n    GT  Limit\n    JMPC Reset\n\n    RET\n\nReset:\n    LD  0\n    ST  Counter\nEND_PROGRAM\n"})})]})}function a(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);